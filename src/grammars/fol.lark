%import common.WS
%import common.NUMBER
%import common.WORD

?search:   exprs | terms

// symbols
?space:      /\s+/                    -> noncapture
?lbrace:     /\(/ space?              -> noncapture
?rbrace:     space? /\)/              -> noncapture
?lcurly:     /{/
?rcurly:     /}/
?noncurly:   /[^\{\}]+/
?comma:      /,/                      -> noncapture
?symb_qsep:  /\.|:/                   -> noncapture
?symb_not:   /!|~|not/                -> noncapture
?symb_or:    /\|+|v|or/               -> noncapture
?symb_and:   /\.|&+|\^|and/           -> noncapture
?symb_impl:  />|-+>|=+>/              -> noncapture
?symb_iff:   /<-+>|<=+>/              -> noncapture
?symb_all:   /all|for all/            -> noncapture
?symb_ex:    /ex|exists|there exists/ -> noncapture
?symb_const: /c|const/i | /c|const/i index | /c|const/i indexlabel
?symb_var:   /x|y|z/i | /x|y|z/i index | /x|y|z/i indexlabel
?symb_func:  /\+|\*|\-|f/i | /\+|\*|\-|f/i index | /\+|\*|\-|f/i indexlabel
?symb_reln:  /\+|\*|\-|R/i | /\+|\*|\-|R/i index | /\+|\*|\-|R/i indexlabel

// text labels
?index: /[0-9]+/
?indexlabel: "{" space? label space? "}"
?label: noncurly | noncurly? ( lcurly label rcurly noncurly? )+

// expressions
?exprs:  expr ( space? comma space? expr )*                                 -> exprs
?expr:   expropen | exprclosed                                              -> expr
?exprclosed: exprpolish | lbrace expropen rbrace | lbrace exprclosed rbrace -> exprclosed
?expropen:   exprinfix                                                      -> expropen
?exprpolish: relnpolish | not | quantified                                  -> expr
?exprinfix:  relninfix | and | or | implies | iff                           -> expr

// terms
?terms: term ( space? comma space? term )*                                  -> terms
?term: termopen | termclosed                                                -> term
?termclosed: termpolish | lbrace termopen rbrace | lbrace termclosed rbrace -> termclosed
?termopen: terminfix                                                        -> termopen
?termpolish: constant | variable | funcpolish                               -> term
?terminfix: funcinfix                                                       -> term

// constants and variables
?constant: symb_const -> constant
?variable: symb_var   -> variable

// functional expressions
?funcsymbol: symb_func -> symb
?funcpolish: funcsymbol space? lbrace terms rbrace            -> funcpolish
?funcinfix: termclosed ( space funcsymbol space termclosed )+ -> funcinfix

// relational expressions
?relnsymbol: symb_reln -> symb
?relnpolish: relnsymbol space? lbrace terms rbrace            -> relnpolish
?relninfix: termclosed ( space relnsymbol space termclosed )+ -> relninfix

// schema for negation: ¬ F
?not: symb_not space?  exprclosed                           -> not
// schemata for conjunction:  F1 ⋀ F2 ⋀ ... ⋀ Fn
?and: [ exprclosed ( space? symb_and space? exprclosed )+ ] -> and
// schemata for disjunction: F1 ⋁ F2 ⋁ ... ⋁ Fn
?or: [ exprclosed ( space? symb_or space?  exprclosed )+ ]  -> or
// schema for implication: F1 ⟶ F2
?implies: exprclosed space? symb_impl space? exprclosed     -> implies
// schema for iff: F1 ⟷ F2
?iff: exprclosed space? symb_iff space? exprclosed          -> iff
// quantified expressions ∃x.φ(x), ∀x.φ(x)
?quantified: all | exists -> quantified
?all: |
    | symb_all space variable space exprclosed                           -> all
    | symb_all space variable space? symb_qsep space? exprclosed         -> all
    | lbrace symb_all space variable rbrace symb_qsep? space? exprclosed -> all
?exists: |
    | symb_ex space variable space exprclosed                            -> exists
    | symb_ex space variable space? symb_qsep space? exprclosed          -> exists
    | lbrace symb_ex space variable rbrace symb_qsep? space? exprclosed  -> exists
